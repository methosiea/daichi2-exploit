import type { Resolvable } from 'types';

export const unique = <T>(array: T[]): T[] => [...new Set(array)];

/**
 * @description Executes a function async. Can optimize performance for Fetch API calls.
 */
export const exec = <T>(cb: () => T | Promise<T>): Promise<T | undefined> =>
	new Promise<T | undefined>((resolve) => setTimeout(() => resolve(cb()))).catch(() => undefined);

/**
 * @description Throttles function calls.
 */
export const throttle = <T extends (...args: any) => any>(
	cb: T,
	timeout: number
): ((...args: Parameters<T>) => Resolvable<ReturnType<T>>) => {
	let last = 0;

	return (...args: Parameters<T>): Resolvable<ReturnType<T>> => {
		const now = Date.now();
		const next = last + timeout;
		last = now > next ? now : next;
		const diff = next - now;
		const until = diff > 0 ? diff : 0;

		return new Promise<T>((resolve) => setTimeout(() => resolve(cb.apply(null, args)), until)) as Resolvable<ReturnType<T>>;
	};
};

export const normalizeUrl = (url: string) => (url || '').trim().toLowerCase();

export const isObject = (x: unknown): x is object => typeof x === 'object';

export const isString = (x: unknown): x is string => typeof x === 'string';

export const isNonEmptyString = (x: unknown): x is string => isString(x) && x.length > 0;
