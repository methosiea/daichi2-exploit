import { throttle, wget, toSize } from 'utils';
import { getUrls } from './getUrls';
import { ACP_ONLY, GET_URLS_IGNORED_NEEDLES, GET_URLS_IGNORED_FILE_EXTENSIONS } from 'constants';
import type { FormInfo, Forms, Nullable } from 'types';

/**
 *
 */
const getAllForms = throttle(
	async (url, cb: (sources: Forms) => void, _sources: Record<string, Nullable<FormInfo[]>> = { [url]: null }) => {
		const source = await wget(url);
		const ignoredUrls = Object.keys(_sources);
		const urls = getUrls(source, {
			ignoredUrls,
			ignoredNeedles: GET_URLS_IGNORED_NEEDLES,
			ignoredExtensions: GET_URLS_IGNORED_FILE_EXTENSIONS,
			acpOnly: ACP_ONLY,
		});

		for (const url of urls) {
			/**
			 * Ignores /create, /add, /delete, /edit, /trash, /update, /distribute
			 */
			if (/\/(create|add|delete|edit|trash|update|distribute)(\/|\s*$)/is.test(url)) {
				_sources[url] = [];
			} else {
				_sources[url] = null;

				getAllForms(url, cb, _sources);
			}
		}

		const tags = source.match(/<form\s+.*?>.*?<\/form\s*>/gis);
		const forms: FormInfo[] = [];

		if (tags) {
			for (const tag of tags) {
				try {
					const form = $<HTMLFormElement>(tag);
					const action = form.attr('action');

					if (action) {
						const formName = form.attr('name');
						const method = (form.attr('method') ?? '').toUpperCase();
						const query = form.serializeArray();

						forms.push({ formName, action, method, query, pageSize: toSize(source) });
					}
				} catch {}
			}
		}

		_sources[url] = forms;

		if (cb && Object.values(_sources).every((source) => source !== null)) {
			cb(_sources);
		}
	},
	5
);

export const getForms = (startUrl: string): Promise<Forms> =>
	new Promise((resolve) => getAllForms(startUrl, (sources) => resolve(sources)));
