import { normalizeUrl, unique } from 'utils';

/**
 * @description Retrieve urls related to Daichi.
 */
export function getUrls(
	source: string,
	{
		ignoredUrls = [],
		ignoredNeedles = [],
		ignoredExtensions = [],
		caseSensitive,
		noSSL,
		acpOnly,
	}: {
		ignoredUrls?: string[];
		ignoredNeedles?: string[];
		ignoredExtensions?: string[];
		caseSensitive?: boolean;
		noSSL?: boolean;
		acpOnly?: boolean;
	} = {}
) {
	const urls = source.match(
		new RegExp(`(?:https?:\\/\\/)?(?:www\\.)?daichi2\\.com(?::\\d+)?\\/${acpOnly ? 'acp\\/' : ''}[\\w#?=&.%\\/]+`, 'g')
	);

	if (urls) {
		ignoredUrls = ignoredUrls.map((ignoredUrl) => normalizeUrl(ignoredUrl));
		ignoredNeedles = ignoredNeedles.map((ignoredNeedle) => normalizeUrl(ignoredNeedle));
		ignoredExtensions = ignoredExtensions.map((ignoredExtensions) => normalizeUrl(ignoredExtensions));

		return unique(
			urls
				.map((url) => {
					url = url.trim();

					if (!caseSensitive) {
						url = url.toLowerCase();
					}

					if (!noSSL) {
						/**
						 * In case:
						 * Mixed Content: The page at 'x' was loaded over HTTPS, but requested an insecure resource 'y'.
						 * This request has been blocked; the content must be served over HTTPS.
						 */
						url = url.replace(/^http(?!s)/i, 'https');
					}

					return url;
				})
				.filter((url) => {
					const normalizedUrl = normalizeUrl(url);

					return (
						url &&
						url.length > 0 &&
						!ignoredUrls.some((ignoredUrl) => ignoredUrl === normalizedUrl) &&
						!ignoredNeedles.some((ignoredNeedle) => normalizedUrl.includes(ignoredNeedle)) &&
						!ignoredExtensions.some((ignoredExtension) => normalizedUrl.endsWith(ignoredExtension))
					);
				})
		);
	}

	return [];
}
